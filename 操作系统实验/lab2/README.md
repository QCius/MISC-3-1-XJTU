# lab2

# PART 1

* 如果在5秒内父进程接收到 SIGINT 或 SIGQUIT 信号，那么程序会在父进程接收到信号后立即向两个子进程分别发送信号16和17，子进程将相应地终止。最后，父进程终止。

* 如果在5秒内父进程没有接收到 SIGINT 或 SIGQUIT 信号，那么会收到SIGALRM信号，然后父进程将向两个子进程分别发送信号16和17，子进程将相应地终止。最后，父进程终止。




# PART 2


* 加锁时是写入的'1'和'2'是连续的。这是因为子进程1和子进程2在写入管道时使用 lockf 函数进行加锁，以确保一次只有一个子进程能够写入数据。这样实现了连续的写入。

* 不加锁时二者在一段时间后交替出现。这与write原子性有关。
  
* 同步通过wait实现。这确保了写程序完成后读程序才开始读，二者之间的同步关系是保证顺利完成读写必要条件。此例中另一种确保同步的方式可以是在父进程中用sleep等待。   
* 互斥通过子进程在写入管道时使用 lockf 函数来实现。两个子程序都试图锁定管道，但只有一个子进程可以成功锁定，另一个会被阻塞。这确保了在任何时刻只有一个子进程能够写入数据，防止了竞争条件和数据混乱。  

# PART 3

* 内存系统模拟